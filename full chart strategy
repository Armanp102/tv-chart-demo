<!DOCTYPE html>
<html lang="fa">

<head>
  <meta charset="UTF-8" />
  <title>Ù†Ù…ÙˆØ¯Ø§Ø± Ø¨Ø§ Ù…Ø§Ø±Ú©Ø±</title>
  <script src="https://unpkg.com/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    body {
      margin: 0;
      font-family: Arial;
      background-color: #181818;
    }

    #chart {
      height: 100vh;
      width: 100vw;
      position: relative;
    }

    #loading {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 6px 12px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 14px;
      border-radius: 4px;
      z-index: 999;
    }

    #scrollToEndBtn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      z-index: 1000;
    }

    #scrollToEndBtn:hover {
      background-color: #0056b3;
    }
  </style>
</head>

<body>
  <div id="loading">Ø¯Ø± Ø­Ø§Ù„ Ù„ÙˆØ¯...</div>
  <div id="chart"></div>

  <script>
    // Ø§ÛŒØ¬Ø§Ø¯ Ú†Ø§Ø±Øª
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
      layout: {
        background: { color: '#161A25' }, // Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø¯Ø§Ø±Ú©
        textColor: '#ffffff', // Ø±Ù†Ú¯ Ù…ØªÙ† Ø³ÙÛŒØ¯
      },
      timeScale: {
        timeVisible: true,
        secondsVisible: false,
        borderColor: '#444444' // Ø±Ù†Ú¯ Ø®Ø· Ù…Ø±Ø² ØªØ§ÛŒÙ… Ø§Ø³Ú©ÛŒÙ„
      },
      grid: {
        vertLines: { color: '#a0a0a01f' }, // Ø±Ù†Ú¯ Ø®Ø·ÙˆØ· Ø¹Ù…ÙˆØ¯ÛŒ
        horzLines: { color: '#a0a0a01f' }, // Ø±Ù†Ú¯ Ø®Ø·ÙˆØ· Ø§ÙÙ‚ÛŒ
      },
      crosshair: {
        vertLine: {
          color: '#888888', // Ø±Ù†Ú¯ Ø®Ø· Ø¹Ù…ÙˆØ¯ÛŒ crosshair
          width: 1
        },
        horzLine: {
          color: '#888888', // Ø±Ù†Ú¯ Ø®Ø· Ø§ÙÙ‚ÛŒ crosshair
          width: 1
        }
      }
    });

    // Ù…Ø­Ø§Ø³Ø¨Ù‡ McGinley Dynamic
    function mcginley(series, length) {
      let result = [series[0]];
      for (let i = 1; i < series.length; i++) {
        const prev = result[i - 1];
        const price = series[i];
        const newVal = prev + (price - prev) / (length * Math.pow(price / prev, 2));
        result.push(newVal);
      }
      return result;
    }

    // Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA
    function calculateEMA(data, period) {
      const k = 2 / (period + 1);
      const emaArray = [];
      let ema = data[0].close;  // Ø´Ø±ÙˆØ¹ Ø¨Ø§ Ø§ÙˆÙ„ÛŒÙ† Ú©Ù†Ø¯Ù„

      for (let i = 0; i < data.length; i++) {
        const price = data[i].close;
        if (i === 0) {
          emaArray.push(price);  // EMA Ø§ÙˆÙ„ Ù…Ø³Ø§ÙˆÛŒ Ù‚ÛŒÙ…Øª Ø§ÙˆÙ„
        } else {
          ema = price * k + ema * (1 - k);
          emaArray.push(ema);
        }
      }

      return emaArray;
    }


    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Trendilo (ALMA)
    function alma(series, window, offset, sigma) {
      const m = offset * (window - 1);
      const s = window / sigma;
      const result = [];

      for (let i = 0; i < series.length; i++) {
        if (i < window) {
          result.push(null);
          continue;
        }

        let weightedSum = 0;
        let norm = 0;

        for (let j = 0; j < window; j++) {
          const weight = Math.exp(-Math.pow(j - m, 2) / (2 * s * s));
          weightedSum += series[i - window + j] * weight;
          norm += weight;
        }

        result.push(weightedSum / norm);
      }

      return result;
    }


    // Ù…Ø­Ø§Ø³Ø¨Ù‡ DMI Ùˆ ADX
    // ØªØ§Ø¨Ø¹ RMA Ø¯Ù‚ÛŒÙ‚ (Root Moving Average Ù…Ø§Ù†Ù†Ø¯ Pine Script)
    function rma(values, period) {
      const result = [];
      let sum = 0;

      for (let i = 0; i < values.length; i++) {
        const val = values[i];
        if (i < period) {
          sum += val;
          result.push(null);  // Ø¨Ø±Ø§ÛŒ Ù‡Ù…â€ŒØªØ±Ø§Ø²ÛŒ Ø¨Ø§ ØªØ±ÛŒØ¯ÛŒÙ†Ú¯â€ŒÙˆÛŒÙˆ
        } else if (i === period) {
          sum += val;
          const rmaInit = sum / (period + 1);  // divisor Ù…Ø·Ø§Ø¨Ù‚ Pine Script
          result.push(rmaInit);
        } else {
          const prev = result[result.length - 1];
          result.push((prev * (period - 1) + val) / period);
        }
      }

      return result;
    }

    // Ù…Ø­Ø§Ø³Ø¨Ù‡ DMI Ùˆ ADX
    function calculateDMI(data, diLength = 14, adxSmoothing = 14) {
      const plusDM = [], minusDM = [], tr = [];

      for (let i = 1; i < data.length; i++) {
        const upMove = data[i].high - data[i - 1].high;
        const downMove = data[i - 1].low - data[i].low;

        plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
        minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);

        const trueRange = Math.max(
          data[i].high - data[i].low,
          Math.abs(data[i].high - data[i - 1].close),
          Math.abs(data[i].low - data[i - 1].close)
        );
        tr.push(trueRange);
      }

      const trRma = rma(tr, diLength);
      const plusRma = rma(plusDM, diLength);
      const minusRma = rma(minusDM, diLength);

      const plusDI = plusRma.map((v, i) =>
        v !== null && trRma[i] ? 100 * v / trRma[i] : null
      );
      const minusDI = minusRma.map((v, i) =>
        v !== null && trRma[i] ? 100 * v / trRma[i] : null
      );

      const dx = plusDI.map((p, i) => {
        const m = minusDI[i];
        if (p === null || m === null) return null;
        const sum = p + m;
        return sum === 0 ? 0 : 100 * Math.abs(p - m) / sum;
      });

      const adx = rma(dx, adxSmoothing);

      // Ù‡Ù…â€ŒØªØ±Ø§Ø²ÛŒ Ø¨Ø§ Ø·ÙˆÙ„ Ø¯Ø§Ø¯Ù‡ Ø§ØµÙ„ÛŒ (Ú†ÙˆÙ† Ø§Ø² Ú©Ù†Ø¯Ù„ Ø¯ÙˆÙ… Ø´Ø±ÙˆØ¹ Ø´Ø¯Ù‡)
      return [[null, ...plusDI], [null, ...minusDI], [null, ...adx]];
    }

    const candleSeries = chart.addCandlestickSeries();

    const INTERVAL = 15 * 60 * 1000; // 15m in ms
    let allCandles = [];  // Ù„ÛŒØ³Øª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
    let earliestTime = null;
    let latestCandleTime = null;
    let loading = false;

    async function fetchCandles(start, end) {
      const url = `https://api.binance.com/api/v3/klines?symbol=AVAXUSDT&interval=15m&limit=1000&startTime=${start}&endTime=${end}`;
      const res = await fetch(url);
      const data = await res.json();
      return data.map(d => ({
        time: Math.floor(d[0] / 1000),
        open: parseFloat(d[1]),
        high: parseFloat(d[2]),
        low: parseFloat(d[3]),
        close: parseFloat(d[4])
      }));
    }

    async function loadInitial() {
      const end = Date.now();
      const start = end - 500 * INTERVAL;
      const candles = await fetchCandles(start, end);

      if (candles.length > 0) {
        allCandles = candles;
        earliestTime = candles[0].time * 1000;
        latestCandleTime = candles[candles.length - 1].time * 1000;
        candleSeries.setData(allCandles);

        // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
        const closes = allCandles.map(c => c.close);
        const mcLine = mcginley(closes, inputValues.mcGinleyPeriod);
        const emaFast = calculateEMA(allCandles, inputValues.emaFast);
        const emaSlow = calculateEMA(allCandles, inputValues.emaSlow);
        const [plusDI, minusDI, adxArray] = calculateDMI(allCandles, inputValues.diLength, inputValues.adxSmoothing);

        // Ø§Ø¬Ø±Ø§ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø±ÙˆÛŒ Ù‡Ù…Ù‡ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
        allCandles.forEach((candle, index) => {
          checkStrategy(candle, index, mcLine, emaFast, emaSlow, adxArray);
        });

        candleSeries.setMarkers(strategyMarkers);
      }
    }

    const inputValues = {
      mcGinleyPeriod: 6,
      emaFast: 21,
      emaSlow: 55,
      trendiloLookback: 47,
      trendiloOffset: 0.85,
      trendiloSigma: 6,
      diLength: 14,
      adxSmoothing: 14,
      adxThreshold: 30
    };
    async function loadMoreCandles() {
      const end = earliestTime - 1;
      const start = end - 1000 * INTERVAL;  // Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ± Ø§Ø² WebSocket
      try {
        const moreCandles = await fetchCandles(start, end);

        if (moreCandles.length > 0) {

          allCandles = [...moreCandles, ...allCandles];  // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ Ø§ÙˆÙ„ Ù„ÛŒØ³Øª
          earliestTime = moreCandles[0].time * 1000;

          candleSeries.setData(allCandles);  // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú†Ø§Ø±Øª Ø¨Ø§ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯

          // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ Ùˆ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§
          const closes = allCandles.map(c => c.close);
          const mcLine = mcginley(closes, inputValues.mcGinleyPeriod);
          const emaFast = calculateEMA(allCandles, inputValues.emaFast);
          const emaSlow = calculateEMA(allCandles, inputValues.emaSlow);
          const [plusDI, minusDI, adxArray] = calculateDMI(allCandles, inputValues.diLength, inputValues.adxSmoothing);

          strategyMarkers = [];
          allCandles.forEach((candle, index) => {
            checkStrategy(candle, index, mcLine, emaFast, emaSlow, adxArray);
          });
          candleSeries.setMarkers(strategyMarkers);

        }
      } catch (error) {
        console.error('Error fetching more candles:', error);
      }
    }

    chart.timeScale().subscribeVisibleLogicalRangeChange(async (range) => {
      if (loading || !range) return;

      const bars = candleSeries.barsInLogicalRange(range);

      // Ø§Ú¯Ø± ØªØ¹Ø¯Ø§Ø¯ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø§Ø² Ù…Ù‚Ø¯Ø§Ø± Ù…Ø´Ø®Øµ Ú©Ù…ØªØ± Ø§Ø³ØªØŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ± Ù„ÙˆØ¯ Ù…ÛŒâ€ŒØ´ÙˆØ¯
      if (bars && bars.barsBefore < 50) {
        loading = true;
        await loadMoreCandles();  // Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ±
        loading = false;
      }
    });

    function updateCountdown() {
      if (!latestCandleTime) return;
      const now = Date.now();
      const next = latestCandleTime + INTERVAL;
      const remaining = Math.max(0, Math.floor((next - now) / 1000));
      const m = String(Math.floor(remaining / 60)).padStart(2, '0');
      const s = String(remaining % 60).padStart(2, '0');
      const text = `${m}:${s}`;
      document.getElementById("loading").textContent = text;
    }

const tp_percent = 2; // Ø¯Ø±ØµØ¯ Take Profit
const sl_percent = 4; // Ø¯Ø±ØµØ¯ Stop Loss

let positionOpen = false;
let positionType = null;
let entryPrice = null;
let stopLoss = null;
let takeProfit = null;
let strategyMarkers = [];

function checkStrategy(candle, index, mcLine, emaFastArr, emaSlowArr, adxArray) {
  if (!mcLine || !emaFastArr || !emaSlowArr || !adxArray) return;
  if (index === 0) return;

  const close = candle.close;
  const open = candle.open;
  const high = candle.high;
  const low = candle.low;

  const isGreen = close > open;
  const isRed = close < open;

  const mc = mcLine[index];
  const mcPrev = mcLine[index - 1];
  const closePrev = allCandles[index - 1]?.close;

  const crossOver = closePrev < mcPrev && close > mc;
  const crossUnder = closePrev > mcPrev && close < mc;

  const ema1 = emaFastArr[index];
  const ema2 = emaSlowArr[index];
  const adx = adxArray[index];
  const strongTrend = adx !== null && adx > 25;

  const longCond = isGreen && crossOver && ema1 > ema2 && strongTrend;
  const shortCond = isRed && crossUnder && ema1 < ema2 && strongTrend;

  // ÙÙ‚Ø· Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø§Ø² Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŒ Ù„Ø§Ú¯ Ùˆ Ù…Ø§Ø±Ú©Ø± Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ….
  if (!positionOpen) {
    if (longCond) {
      positionOpen = true;
      positionType = "long";
      entryPrice = close;
      stopLoss = close * (1 - sl_percent / 100);
      takeProfit = close * (1 + tp_percent / 100);

      strategyMarkers.push({
        time: candle.time,
        position: 'belowBar',
        color: 'green',
        shape: 'arrowUp',
        text: 'LONG âœ…'
      });

      // Ù„Ø§Ú¯ Ø¨Ø±Ø§ÛŒ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù¾ÙˆØ²ÛŒØ´Ù† LONG
      console.log(`Opening LONG position at ${new Date(candle.time * 1000).toLocaleString()}`);
      console.log(`Entry Price: ${entryPrice}, SL: ${stopLoss}, TP: ${takeProfit}`);
      console.log(`McGinley: ${mc}, EMA Fast: ${ema1}, EMA Slow: ${ema2}, ADX: ${adx}`);
    }

    if (shortCond) {
      positionOpen = true;
      positionType = "short";
      entryPrice = close;
      stopLoss = close * (1 + sl_percent / 100);
      takeProfit = close * (1 - tp_percent / 100);

      strategyMarkers.push({
        time: candle.time,
        position: 'aboveBar',
        color: 'red',
        shape: 'arrowDown',
        text: 'SHORT â›”ï¸'
      });

      // Ù„Ø§Ú¯ Ø¨Ø±Ø§ÛŒ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù¾ÙˆØ²ÛŒØ´Ù† SHORT
      console.log(`Opening SHORT position at ${new Date(candle.time * 1000).toLocaleString()}`);
      console.log(`Entry Price: ${entryPrice}, SL: ${stopLoss}, TP: ${takeProfit}`);
      console.log(`McGinley: ${mc}, EMA Fast: ${ema1}, EMA Slow: ${ema2}, ADX: ${adx}`);
    }
  }

  // Ø¨Ø±Ø±Ø³ÛŒ TP Ùˆ SL Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬
  if (positionOpen) {
    if (positionType === "long") {
      if (candle.low <= stopLoss) {
        positionOpen = false;
        strategyMarkers.push({
          time: candle.time,
          position: 'aboveBar',
          color: 'gray',
          shape: 'circle',
          text: 'SL âŒ'
        });

        // Ù„Ø§Ú¯ Ø¨Ø±Ø§ÛŒ Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ SL Ø¯Ø± Ù¾ÙˆØ²ÛŒØ´Ù† LONG
        console.log(`LONG position hit SL at ${stopLoss} on Candle @ ${new Date(candle.time * 1000).toLocaleString()}`);
      } else if (candle.high >= takeProfit) {
        positionOpen = false;
        strategyMarkers.push({
          time: candle.time,
          position: 'aboveBar',
          color: 'blue',
          shape: 'circle',
          text: 'TP ğŸ¯'
        });

        // Ù„Ø§Ú¯ Ø¨Ø±Ø§ÛŒ Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ TP Ø¯Ø± Ù¾ÙˆØ²ÛŒØ´Ù† LONG
        console.log(`LONG position hit TP at ${takeProfit} on Candle @ ${new Date(candle.time * 1000).toLocaleString()}`);
      }
    }

    if (positionType === "short") {
      if (candle.high >= stopLoss) {
        positionOpen = false;
        strategyMarkers.push({
          time: candle.time,
          position: 'belowBar',
          color: 'gray',
          shape: 'circle',
          text: 'SL âŒ'
        });

        // Ù„Ø§Ú¯ Ø¨Ø±Ø§ÛŒ Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ SL Ø¯Ø± Ù¾ÙˆØ²ÛŒØ´Ù† SHORT
        console.log(`SHORT position hit SL at ${stopLoss} on Candle @ ${new Date(candle.time * 1000).toLocaleString()}`);
      } else if (candle.low <= takeProfit) {
        positionOpen = false;
        strategyMarkers.push({
          time: candle.time,
          position: 'belowBar',
          color: 'blue',
          shape: 'circle',
          text: 'TP ğŸ¯'
        });

        // Ù„Ø§Ú¯ Ø¨Ø±Ø§ÛŒ Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ TP Ø¯Ø± Ù¾ÙˆØ²ÛŒØ´Ù† SHORT
        console.log(`SHORT position hit TP at ${takeProfit} on Candle @ ${new Date(candle.time * 1000).toLocaleString()}`);
      }
    }
  }

  // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù…Ø§Ø±Ú©Ø±Ù‡Ø§ Ø¨Ù‡ Ú†Ø§Ø±Øª (ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø§Ø² Ø´Ø¯Ù‡)
  if (strategyMarkers.length > 0) {
    candleSeries.setMarkers(strategyMarkers);
  }
}




    setInterval(updateCountdown, 1000);  // Ø´Ù…Ø§Ø±Ø´ Ù…Ø¹Ú©ÙˆØ³ ØªØ§ Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯ÛŒ

    loadInitial();  // Ù„ÙˆØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡
  </script>
</body>

</html>
