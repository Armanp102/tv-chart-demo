<!DOCTYPE html>
<html lang="fa">

<head>
  <meta charset="UTF-8" />
  <title>Ù†Ù…ÙˆØ¯Ø§Ø± Ø¨Ø§ Ù…Ø§Ø±Ú©Ø±</title>
  <script src="https://unpkg.com/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    body {
      margin: 0;
      font-family: Arial;
      background-color: #181818;
    }

    #chart {
      height: 100vh;
      width: 100vw;
      position: relative;
    }

    #loading {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 6px 12px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 14px;
      border-radius: 4px;
      z-index: 999;
    }

    #scrollToEndBtn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      z-index: 1000;
    }

    #scrollToEndBtn:hover {
      background-color: #0056b3;
    }
  </style>
</head>

<body>
  <div id="loading">Ø¯Ø± Ø­Ø§Ù„ Ù„ÙˆØ¯...</div>
  <div class="input-box">
    <label for="mcGinleyPeriod">McGinley Period:</label>
    <input type="number" id="mcGinleyPeriod" value="6" />
    <br />
    <label for="emaFast">EMA Fast (Cloud Top):</label>
    <input type="number" id="emaFast" value="1" />
    <br />
    <label for="emaSlow">EMA Slow (Cloud Bottom):</label>
    <input type="number" id="emaSlow" value="8" />
    <br />
    <label for="trendiloLookback">Trendilo Lookback:</label>
    <input type="number" id="trendiloLookback" value="44" />
    <br />
    <label for="trendiloOffset">Trendilo ALMA Offset:</label>
    <input type="number" id="trendiloOffset" value="0.85" />
    <br />
    <label for="trendiloSigma">Trendilo Sigma:</label>
    <input type="number" id="trendiloSigma" value="6" />
    <br />
    <label for="adxThreshold">ADX Threshold:</label>
    <input type="number" id="adxThreshold" value="25" />
    <br />
    <br />
    <label for="diLength">DI Length:</label>
    <input type="number" id="diLength" value="14" />
    <br />
    <label for="adxSmoothing">ADX Smoothing:</label>
    <input type="number" id="adxSmoothing" value="14" />
  </div>
  <div id="chart"></div>
  <script>
    // Ø§ÛŒØ¬Ø§Ø¯ Ú†Ø§Ø±Øª
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
      layout: {
        background: { color: '#161A25' }, // Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø¯Ø§Ø±Ú©
        textColor: '#ffffff', // Ø±Ù†Ú¯ Ù…ØªÙ† Ø³ÙÛŒØ¯
      },
      timeScale: {
        timeVisible: true,
        secondsVisible: false,
        borderColor: '#444444' // Ø±Ù†Ú¯ Ø®Ø· Ù…Ø±Ø² ØªØ§ÛŒÙ… Ø§Ø³Ú©ÛŒÙ„
      },
      grid: {
        vertLines: { color: '#a0a0a01f' }, // Ø±Ù†Ú¯ Ø®Ø·ÙˆØ· Ø¹Ù…ÙˆØ¯ÛŒ
        horzLines: { color: '#a0a0a01f' }, // Ø±Ù†Ú¯ Ø®Ø·ÙˆØ· Ø§ÙÙ‚ÛŒ
      },
      crosshair: {
        vertLine: {
          color: '#888888', // Ø±Ù†Ú¯ Ø®Ø· Ø¹Ù…ÙˆØ¯ÛŒ crosshair
          width: 1
        },
        horzLine: {
          color: '#888888', // Ø±Ù†Ú¯ Ø®Ø· Ø§ÙÙ‚ÛŒ crosshair
          width: 1
        }
      }
    });

    function getInputValues() {
      return {
        mcGinleyPeriod: parseInt(document.getElementById('mcGinleyPeriod').value),
        emaFast: parseInt(document.getElementById('emaFast').value),
        emaSlow: parseInt(document.getElementById('emaSlow').value),
        trendiloLookback: parseInt(document.getElementById('trendiloLookback').value),
        trendiloOffset: parseFloat(document.getElementById('trendiloOffset').value),
        trendiloSigma: parseInt(document.getElementById('trendiloSigma').value),
        diLength: parseInt(document.getElementById('diLength').value),
        adxSmoothing: parseInt(document.getElementById('adxSmoothing').value),
        adxThreshold: parseInt(document.getElementById('adxThreshold').value),
      };

    }

    // Ù…Ø­Ø§Ø³Ø¨Ù‡ McGinley Dynamic
    function mcginley(series, length) {
      let result = [series[0]];
      for (let i = 1; i < series.length; i++) {
        const prev = result[i - 1];
        const price = series[i];
        const newVal = prev + (price - prev) / (length * Math.pow(price / prev, 2));
        result.push(newVal);
      }
      return result;
    }

    // Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA Ø·Ø¨Ù‚ Ø±ÙˆØ´ Pine Script
    function calculateEMA(data, period) {
      const k = 2 / (period + 1);
      let emaArray = [];

      // Ú†Ú© Ú©Ø±Ø¯Ù† Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ø§ÙÛŒ Ù‡Ø³ØªÙ†Ø¯
      if (data.length < period) {
        console.error("Not enough data for EMA calculation");
        return [];  // Ø¨Ø§Ø²Ú¯Ø´Øª Ø¢Ø±Ø§ÛŒÙ‡ Ø®Ø§Ù„ÛŒ Ø§Ú¯Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ú©Ø§ÙÛŒ Ù†Ø¨Ø§Ø´Ù†Ø¯
      }

      let emaPrev = data.slice(0, period).reduce((sum, b) => sum + b.close, 0) / period;  // Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø³Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹
      for (let i = 0; i < data.length; i++) {
        if (i < period) {
          emaArray.push(null);  // Ø§Ø¨ØªØ¯Ø§ ØªØ§ Ø¯ÙˆØ±Ù‡ EMA Ù…Ù‚Ø§Ø¯ÛŒØ± null
        } else {
          emaPrev = data[i].close * k + emaPrev * (1 - k);  // ÙØ±Ù…ÙˆÙ„ EMA
          emaArray.push(emaPrev);
        }
      }
      return emaArray;
    }

    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Trendilo (ALMA)
    function alma(series, window, offset, sigma) {
      const m = offset * (window - 1); // Ù…Ø±Ú©Ø²
      const s = window / sigma; // Ø§Ù†Ø­Ø±Ø§Ù Ù…Ø¹ÛŒØ§Ø±
      let wtdSum = []; // Ø¢Ø±Ø§ÛŒÙ‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ù…Ù‚Ø§Ø¯ÛŒØ± ÙˆØ²Ù†â€ŒØ¯Ø§Ø±

      // Ø§ÛŒÙ†Ø¬Ø§ Ø§Ø² ØªÚ©Ø±Ø§Ø± Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø³ØªÛŒ Ø¨Ù‡ Ø¬Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² repeat Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
      for (let i = 0; i < series.length; i++) {
        if (i < window) {
          wtdSum.push(null); // ØªØ§ Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ø¯Ø§Ø¯Ù‡ Ø¨Ù‡ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù¾Ù†Ø¬Ø±Ù‡ Ù„Ø§Ø²Ù… Ù†Ø¨Ø§Ø´Ø¯ null Ù‚Ø±Ø§Ø± Ù…ÛŒâ€ŒØ¯Ù‡ÛŒÙ…
          continue;
        }

        const weights = Array.from({ length: window }, (_, j) =>
          Math.exp(-((j - m) ** 2) / (2 * s * s)) // Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ²Ù†â€ŒÙ‡Ø§
        );

        const norm = weights.reduce((acc, weight) => acc + weight, 0); // Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ ÙˆØ²Ù†â€ŒÙ‡Ø§
        const weightedSum = series.slice(i - window, i).reduce(
          (acc, value, idx) => acc + value * weights[idx],
          0
        ); // Ø¬Ù…Ø¹ ÙˆØ²Ù†â€ŒØ¯Ø§Ø±
        wtdSum.push(weightedSum / norm); // Ø°Ø®ÛŒØ±Ù‡ Ù†ØªÛŒØ¬Ù‡ Ù†Ø±Ù…Ø§Ù„â€ŒØ´Ø¯Ù‡
      }

      // Ú†ÙˆÙ† Ù…Ù‚Ø¯Ø§Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø§Ø¨ØªØ¯Ø§ÛŒÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø¢Ù†Ù‡Ø§ Ø±Ø§ Ø¨Ù‡ null ØªØ¨Ø¯ÛŒÙ„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
      return Array(window).fill(null).concat(wtdSum.slice(window)); // ØªØ±Ú©ÛŒØ¨ Ù†ØªØ§ÛŒØ¬
    }

    function calculateDMI(data, diLength = 14, adxSmoothing = 14) {
      const plusDM = [], minusDM = [], tr = [];

      for (let i = 1; i < data.length; i++) {
        const up = data[i].high - data[i - 1].high;
        const down = data[i - 1].low - data[i].low;

        plusDM.push(up > down && up > 0 ? up : 0);
        minusDM.push(down > up && down > 0 ? down : 0);

        const highLow = data[i].high - data[i].low;
        const highClose = Math.abs(data[i].high - data[i - 1].close);
        const lowClose = Math.abs(data[i].low - data[i - 1].close);
        tr.push(Math.max(highLow, highClose, lowClose));
      }

      function rma(values, period) {
        const result = [];
        let sum = 0;
        for (let i = 0; i < values.length; i++) {
          if (i < period) {
            sum += values[i];
            result.push(null);
          } else if (i === period) {
            sum += values[i];
            result.push(sum / period);
          } else {
            const prev = result[result.length - 1];
            result.push((prev * (period - 1) + values[i]) / period);
          }
        }
        return result;
      }

      const trRma = rma(tr, diLength);
      const plusRma = rma(plusDM, diLength);
      const minusRma = rma(minusDM, diLength);

      const plusDI = plusRma.map((val, i) =>
        val !== null && trRma[i] ? (100 * val) / trRma[i] : null
      );
      const minusDI = minusRma.map((val, i) =>
        val !== null && trRma[i] ? (100 * val) / trRma[i] : null
      );
      const dx = plusDI.map((val, i) => {
        if (val === null && minusDI[i] === null) return null;
        const sum = val + minusDI[i];
        return sum === 0 ? 0 : 100 * Math.abs(val - minusDI[i]) / sum;
      });

      const adx = rma(dx, adxSmoothing);
      // Ù¾Ø¯ÛŒÙ†Ú¯ Ø¨Ø±Ø§ÛŒ ØªØ·Ø§Ø¨Ù‚ Ø¨Ø§ Ø·ÙˆÙ„ Ø¯Ø§Ø¯Ù‡ Ø§ØµÙ„ÛŒ
      const leadingNulls = Array(1).fill(null);
      return [leadingNulls.concat(plusDI), leadingNulls.concat(minusDI), leadingNulls.concat(adx)];
    }

    const candleSeries = chart.addCandlestickSeries();

    const INTERVAL = 15 * 60 * 1000; // 15m in ms
    let allCandles = [];
    let earliestTime = null;
    let latestCandleTime = null;
    let loading = false;

    async function fetchCandles(start, end) {
      const url = `https://api.binance.com/api/v3/klines?symbol=AVAXUSDT&interval=15m&limit=1000&startTime=${start}&endTime=${end}`;
      const res = await fetch(url);
      const data = await res.json();
      return data.map(d => ({
        time: Math.floor(d[0] / 1000),
        open: parseFloat(d[1]),
        high: parseFloat(d[2]),
        low: parseFloat(d[3]),
        close: parseFloat(d[4])
      }));
    }

    // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø§Ø±Ú©Ø±Ù‡Ø§ Ø¨Ø§ ØªØºÛŒÛŒØ± ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§
    function updateMarkers() {
      const inputValues = getInputValues();  // Ø¯Ø±ÛŒØ§ÙØª Ù…Ù‚Ø§Ø¯ÛŒØ± ÙˆØ±ÙˆØ¯ÛŒ Ø§Ø² Ú©Ø§Ø±Ø¨Ø±

      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
      const closes = allCandles.map(c => c.close);
      const mcLine = mcginley(closes, inputValues.mcGinleyPeriod);
      const emaFast = calculateEMA(allCandles, inputValues.emaFast);  // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙˆØ±ÙˆØ¯ÛŒ Ø¨Ø±Ø§ÛŒ EMA ÙØ³Øª
      const emaSlow = calculateEMA(allCandles, inputValues.emaSlow);  // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙˆØ±ÙˆØ¯ÛŒ Ø¨Ø±Ø§ÛŒ EMA Ú©Ù†Ø¯
      const [plusDI, minusDI, adxArray] = calculateDMI(allCandles, inputValues.diLength, inputValues.adxSmoothing);
      const htfTrendArr = Array(allCandles.length).fill(true);  // ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… Ø¨Ø§Ù„Ø§ØªØ± (Ù…ÙˆÙ‚ØªØ§Ù‹)

      // Ø­Ø°Ù Ù…Ø§Ø±Ú©Ø±Ù‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
      strategyMarkers = [];

      // Ø§Ø¹Ù…Ø§Ù„ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¨Ø±Ø§ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
      allCandles.forEach((candle, i) => {
        checkStrategy(candle, i, mcLine, emaFast, emaSlow, adxArray, htfTrendArr);
      });

      // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù…Ø§Ø±Ú©Ø±Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
      candleSeries.setMarkers(strategyMarkers);
    }

    async function loadInitial() {
      const end = Date.now();
      const start = end - 500 * INTERVAL;
      const candles = await fetchCandles(start, end);

      if (candles.length > 0) {
        allCandles = candles;
        earliestTime = candles[0].time * 1000;
        latestCandleTime = candles[candles.length - 1].time * 1000;
        candleSeries.setData(allCandles);

        // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ù…Ø§Ø±Ú©Ø±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡
        updateMarkers();
      }

      startWebSocket();  // Ù¾Ø³ Ø§Ø² Ø§ÛŒÙ† Ú©Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù†ØŒ ÙˆØ¨â€ŒØ³ÙˆÚ©Øª Ø´Ø±ÙˆØ¹ Ù…ÛŒØ´Ù‡
    }



    let sl_percent = 4.0;  // Ø¯Ø±ØµØ¯ ØªÙˆÙ‚Ù Ø¶Ø±Ø±
    let tp_percent = 3.0;   // Ø¯Ø±ØµØ¯ Ù‡Ø¯Ù Ø³ÙˆØ¯
    let positionOpen = false;
    let positionType = null; // "long" ÛŒØ§ "short"
    let entryPrice = null;
    let stopLoss = null;
    let takeProfit = null;
    let strategyMarkers = [];

    // Ø§ØµÙ„Ø§Ø­ ØªØ§Ø¨Ø¹ checkStrategy Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² adxArray Ù†Ø§Ù„
    // Ø¨Ø±Ø±Ø³ÛŒ Ùˆ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ Ù…Ù‚Ø§Ø¯ÛŒØ± Ù…Ø­Ø§Ø³Ø¨Ø§ØªÛŒ Ù‡ÛŒÚ†â€ŒÚ©Ø¯Ø§Ù… null Ù†ÛŒØ³ØªÙ†Ø¯
    function checkStrategy(candle, index, mcLine, emaFastArr, emaSlowArr, adxArray, htfTrendArr) {
      // Ø¨Ø±Ø±Ø³ÛŒ null Ø¨ÙˆØ¯Ù† Ù…Ù‚Ø§Ø¯ÛŒØ± Ù‚Ø¨Ù„ Ø§Ø² Ø§Ø³ØªÙØ§Ø¯Ù‡
      if (!mcLine || !emaFastArr || !emaSlowArr || !adxArray || !htfTrendArr) {
        console.error("One of the data arrays is null or undefined.");
        return; // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø§Ú¯Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ù†Ø§Ù‚Øµ Ø¨Ø§Ø´Ù†Ø¯
      }

      const close = candle.close;
      const isGreen = candle.close > candle.open;
      const isRed = candle.close < candle.open;

      const ema1 = emaFastArr[index];
      const ema2 = emaSlowArr[index];
      const mc = mcLine[index];
      const adx = adxArray[index]; // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² adxArray
      const htfTrend = htfTrendArr[index];

      // Ú†Ø§Ù¾ Ù…Ù‚Ø§Ø¯ÛŒØ± Ù…Ø­Ø§Ø³Ø¨Ø§ØªÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ
      console.log("mc:", mc);
      console.log("ema1:", ema1);
      console.log("ema2:", ema2);
      console.log("adx:", adx);
      console.log("htfTrend:", htfTrend);

      if (mc === null || ema1 === null || ema2 === null || adx === null || htfTrend === null) {
        console.error("Null value encountered in strategy conditions.");
        return;  // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¯Ø± ØµÙˆØ±Øª null Ø¨ÙˆØ¯Ù† Ù…Ù‚Ø§Ø¯ÛŒØ±
      }

      const strongTrend = adx > 25;

      const longCond = isGreen && close > mc && ema1 > ema2 && strongTrend && htfTrend;
      const shortCond = isRed && close < mc && ema1 < ema2 && strongTrend && !htfTrend;

      console.log(`Candle Time: ${candle.time}`);
      console.log(`Long Condition: ${longCond}`);
      console.log(`Short Condition: ${shortCond}`);

      if (!positionOpen && longCond) {
        positionOpen = true;
        positionType = "long";
        entryPrice = close;
        stopLoss = close * (1 - sl_percent / 100);
        takeProfit = close * (1 + tp_percent / 100);
        strategyMarkers.push({
          time: candle.time,
          position: 'belowBar',
          color: 'white',
          shape: 'arrowUp',
          text: 'ÙˆØ±ÙˆØ¯ Ù„Ø§Ù†Ú¯',
        });
      }

      if (!positionOpen && shortCond) {
        positionOpen = true;
        positionType = "short";
        entryPrice = close;
        stopLoss = close * (1 + sl_percent / 100);
        takeProfit = close * (1 - tp_percent / 100);
        strategyMarkers.push({
          time: candle.time,
          position: 'aboveBar',
          color: 'red',
          shape: 'arrowDown',
          text: 'ÙˆØ±ÙˆØ¯ Ø´ÙˆØ±Øª',
        });
      }

      if (positionOpen) {
        if (positionType === "long") {
          if (close <= stopLoss || close >= takeProfit) {
            strategyMarkers.push({
              time: candle.time,
              position: 'aboveBar',
              color: 'white',
              shape: 'circle',
              text: close >= takeProfit ? 'TP ğŸ¯' : 'SL âŒ'
            });
            positionOpen = false;
          }
        }
        if (positionType === "short") {
          if (close >= stopLoss || close <= takeProfit) {
            strategyMarkers.push({
              time: candle.time,
              position: 'belowBar',
              color: 'white',
              shape: 'circle',
              text: close <= takeProfit ? 'TP ğŸ¯' : 'SL âŒ'
            });
            positionOpen = false;
          }
        }
      }

      console.log("Strategy Markers:", strategyMarkers);
    }

    // Ø§ØµÙ„Ø§Ø­ ØªØ§Ø¨Ø¹ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ùˆ Ø§Ø¹Ù…Ø§Ù„ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¨Ø±Ø§ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
    chart.timeScale().subscribeVisibleLogicalRangeChange(async (range) => {
      if (loading || !range) return;

      const bars = candleSeries.barsInLogicalRange(range);

      if (bars && bars.barsBefore < 50) {
        loading = true;

        const end = earliestTime - 1;
        const start = end - 1000 * INTERVAL;

        try {
          const more = await fetchCandles(start, end);

          if (more.length > 0) {
            allCandles = [...more, ...allCandles];
            earliestTime = more[0].time * 1000;

            candleSeries.setData(allCandles);

            // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ù‚Ø§Ø¯ÛŒØ± ÙˆØ±ÙˆØ¯ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
            resetInputValues();  // Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ù…Ù‚Ø§Ø¯ÛŒØ± ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§ Ø¨Ù‡ Ù…Ù‚Ø§Ø¯ÛŒØ± Ø§ÙˆÙ„ÛŒÙ‡

            // Ù…Ø­Ø§Ø³Ø¨Ù‡ mcLine Ùˆ adxArray Ùˆ htfTrendArr Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
            const closes = allCandles.map(c => c.close);
            const mcLine = mcginley(closes, 14);  // ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ ØªØ§Ø¨Ø¹ mcginley Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ mcLine
            const [plusDI, minusDI, adxArray] = calculateDMI(allCandles, 14, 14); // Ù…Ø­Ø§Ø³Ø¨Ù‡ ADX
            const htfTrendArr = Array(allCandles.length).fill(true);  // ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… Ø¨Ø§Ù„Ø§ØªØ± (Ù…ÙˆÙ‚ØªØ§Ù‹)

            // Ù„Ø§Ú¯ Ù…Ù‚Ø§Ø¯ÛŒØ± Ù…Ø­Ø§Ø³Ø¨Ø§ØªÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø§Ø³ØªÙØ§Ø¯Ù‡
            console.log("mcLine: ", mcLine);
            console.log("emaFast: ", emaFast);
            console.log("emaSlow: ", emaSlow);
            console.log("adxArray: ", adxArray);
            console.log("htfTrendArr: ", htfTrendArr);

            // Ø§Ø¹Ù…Ø§Ù„ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯
            more.forEach((candle, i) => {
              const index = allCandles.length - more.length + i;
              checkStrategy(candle, index, mcLine, emaFast, emaSlow, adxArray, htfTrendArr);
            });

            candleSeries.setMarkers(strategyMarkers);
          }
        } catch (error) {
          console.error('Error fetching new candles:', error);
        }

        loading = false;
      }
    });






    // ØªØ§Ø¨Ø¹ WebSocket Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
    // Ø§ØµÙ„Ø§Ø­ ØªØ§Ø¨Ø¹ WebSocket Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ùˆ Ù…Ø­Ø§Ø³Ø¨Ø§Øª
    // Ø§ØµÙ„Ø§Ø­ ØªØ§Ø¨Ø¹ WebSocket Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ùˆ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø§Ø±Ú©Ø±Ù‡Ø§
    function startWebSocket() {
      const ws = new WebSocket('wss://stream.binance.com:9443/ws/avaxusdt@kline_15m');

      ws.onmessage = (event) => {
        const k = JSON.parse(event.data).k;
        const candle = {
          time: Math.floor(k.t / 1000),
          open: parseFloat(k.o),
          high: parseFloat(k.h),
          low: parseFloat(k.l),
          close: parseFloat(k.c)
        };

        // Ù„ÙˆØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ WebSocket
        candleSeries.update(candle);
        latestCandleTime = k.t;

        // Ù…Ø­Ø§Ø³Ø¨Ù‡ EMA Ùˆ Ø³Ø§ÛŒØ± Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
        const closes = allCandles.map(c => c.close);
        const mcLine = mcginley(closes, 14);  // ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ ØªØ§Ø¨Ø¹ mcginley Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ mcLine
        const [plusDI, minusDI, adxArray] = calculateDMI(allCandles, 14, 14); // Ù…Ø­Ø§Ø³Ø¨Ù‡ ADX
        const htfTrendArr = Array(allCandles.length).fill(true);  // ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… Ø¨Ø§Ù„Ø§ØªØ± (Ù…ÙˆÙ‚ØªØ§Ù‹)

        // Ø§Ø¹Ù…Ø§Ù„ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯
        checkStrategy(candle, allCandles.length - 1, mcLine, emaFast, emaSlow, adxArray, htfTrendArr);

        // Ø¨Ù‡ Ø±ÙˆØ² Ø±Ø³Ø§Ù†ÛŒ Ù…Ø§Ø±Ú©Ø±Ù‡Ø§ Ø¨Ø¹Ø¯ Ø§Ø² Ù‡Ø± Ø¨Ø§Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯
        candleSeries.setMarkers(strategyMarkers);
      };

      ws.onclose = () => setTimeout(startWebSocket, 5000);  // Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯ WebSocket Ø¯Ø± ØµÙˆØ±Øª Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„
    }

    // ØªØ§Ø¨Ø¹ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ùˆ Ø¨Ù‡ Ø±ÙˆØ² Ø±Ø³Ø§Ù†ÛŒ Ù…Ø§Ø±Ú©Ø±Ù‡Ø§
    chart.timeScale().subscribeVisibleLogicalRangeChange(async (range) => {
      if (loading || !range) return;

      const bars = candleSeries.barsInLogicalRange(range);

      if (bars && bars.barsBefore < 50) {
        loading = true;

        const end = earliestTime - 1;
        const start = end - 1000 * INTERVAL;

        try {
          const more = await fetchCandles(start, end);

          if (more.length > 0) {
            allCandles = [...more, ...allCandles];
            earliestTime = more[0].time * 1000;

            candleSeries.setData(allCandles);

            // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ù‚Ø§Ø¯ÛŒØ± ÙˆØ±ÙˆØ¯ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
            resetInputValues();  // Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ù…Ù‚Ø§Ø¯ÛŒØ± ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§ Ø¨Ù‡ Ù…Ù‚Ø§Ø¯ÛŒØ± Ø§ÙˆÙ„ÛŒÙ‡

            // Ù…Ø­Ø§Ø³Ø¨Ù‡ mcLine Ùˆ adxArray Ùˆ htfTrendArr Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
            const closes = allCandles.map(c => c.close);
            const mcLine = mcginley(closes, 14);  // ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ ØªØ§Ø¨Ø¹ mcginley Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ mcLine
            const [plusDI, minusDI, adxArray] = calculateDMI(allCandles, 14, 14); // Ù…Ø­Ø§Ø³Ø¨Ù‡ ADX
            const htfTrendArr = Array(allCandles.length).fill(true);  // ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… Ø¨Ø§Ù„Ø§ØªØ± (Ù…ÙˆÙ‚ØªØ§Ù‹)

            // Ø§Ø¹Ù…Ø§Ù„ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ú©Ù†Ø¯Ù„ Ø¬Ø¯ÛŒØ¯
            more.forEach((candle, i) => {
              const index = allCandles.length - more.length + i;
              checkStrategy(candle, index, mcLine, emaFast, emaSlow, adxArray, htfTrendArr);
            });

            // Ø¨Ù‡ Ø±ÙˆØ² Ø±Ø³Ø§Ù†ÛŒ Ù…Ø§Ø±Ú©Ø±Ù‡Ø§ Ø¨Ø¹Ø¯ Ø§Ø² Ù‡Ø± Ø¨Ø§Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
            candleSeries.setMarkers(strategyMarkers);
          }
        } catch (error) {
          console.error('Error fetching new candles:', error);
        }

        loading = false;
      }
    });

    function updateCountdown() {
      if (!latestCandleTime) return;
      const now = Date.now();
      const next = latestCandleTime + INTERVAL;
      const remaining = Math.max(0, Math.floor((next - now) / 1000));
      const m = String(Math.floor(remaining / 60)).padStart(2, '0');
      const s = String(remaining % 60).padStart(2, '0');
      const text = `${m}:${s}`;
      document.getElementById("loading").textContent = text;
    }

    loadInitial();
    startWebSocket();
    setInterval(updateCountdown, 1000);



    let strategySeries = chart.addLineSeries({ color: 'transparent' });
    let mcGinleySeries = null;
    let emaFastSeries = null;
    let emaSlowSeries = null;
    let trendiloSeries = null;

    function drawMcGinley() {
      const inputValues = getInputValues();
      const candles = allCandles;
      if (!candles || candles.length === 0) return;

      const closes = candles.map(d => d.close);
      const mcLine = mcginley(closes, inputValues.mcGinleyPeriod);

      if (mcGinleySeries) chart.removeSeries(mcGinleySeries);

      mcGinleySeries = chart.addLineSeries({ color: 'orange', lineWidth: 2 });
      mcGinleySeries.setData(
        candles.map((d, i) => {
          const value = mcLine[i];
          return value != null && !isNaN(value) ? { time: d.time, value } : null;
        }).filter(Boolean)
      );
    }

    function drawEMA() {
      const inputValues = getInputValues();
      const candles = allCandles;
      if (!candles || candles.length === 0) return;

      const emaFast = calculateEMA(candles, inputValues.emaFast);
      const emaSlow = calculateEMA(candles, inputValues.emaSlow);

      if (emaFastSeries) chart.removeSeries(emaFastSeries);
      if (emaSlowSeries) chart.removeSeries(emaSlowSeries);

      emaFastSeries = chart.addLineSeries({ color: 'green', lineWidth: 2 });
      emaFastSeries.setData(
        candles.map((d, i) => {
          const value = emaFast[i];
          return value != null && !isNaN(value) ? { time: d.time, value } : null;
        }).filter(Boolean)
      );

      emaSlowSeries = chart.addLineSeries({ color: 'red', lineWidth: 2 });
      emaSlowSeries.setData(
        candles.map((d, i) => {
          const value = emaSlow[i];
          return value != null && !isNaN(value) ? { time: d.time, value } : null;
        }).filter(Boolean)
      );
    }

    function drawTrendilo() {
      const inputValues = getInputValues();
      const candles = allCandles;
      if (!candles || candles.length === 0) return;

      const closes = candles.map(d => d.close);
      const trendilo = alma(closes, inputValues.trendiloLookback, inputValues.trendiloOffset, inputValues.trendiloSigma);

      if (trendiloSeries) chart.removeSeries(trendiloSeries);

      trendiloSeries = chart.addLineSeries({ color: 'blue', lineWidth: 2 });
      trendiloSeries.setData(
        candles.map((d, i) => {
          const value = trendilo[i];
          return value != null && !isNaN(value) ? { time: d.time, value } : null;
        }).filter(Boolean)
      );
    }

    // Ø§Ø¬Ø±Ø§ Ø¯Ø± Ø§Ø¨ØªØ¯Ø§
    loadInitial().then(() => {
      drawMcGinley();
      drawEMA();
      drawTrendilo();
    });

    // ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ updateMarkers Ù‡Ù†Ú¯Ø§Ù… ØªØºÛŒÛŒØ± ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§
    ['mcGinleyPeriod', 'emaFast', 'emaSlow', 'trendiloLookback', 'trendiloOffset', 'trendiloSigma', 'diLength', 'adxSmoothing', 'adxThreshold'].forEach(id => {
      document.getElementById(id).addEventListener('input', updateMarkers);
    });

    let redrawTimeout;
    chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
      clearTimeout(redrawTimeout);
      redrawTimeout = setTimeout(() => {
        drawMcGinley();
        drawEMA();
        drawTrendilo();
      }, 150);
    });
  </script>
</body>